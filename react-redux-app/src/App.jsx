// Redux

// 중앙 state 관리소를 사용할 수 있게 도와주는 패키지(라이브러리)다.
// 프론트엔드 개발자들은 리덕스를 "전역 상태 관리 라이브러리" 라고 많이 표현한다.
// 전역 상태, 즉 Global State를 의미하고 그것을 관리하게 도와주는 패키지(라이브러리)이기 때문이다.

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// Local state (지역상태)
// 컴포넌트에서 useState를 이용하여 생성한 state다.
// 좁은 범위 안에서 생성된 State라고 생각하면 된다.

// Global state (전역상태)
// Global state는 컴포넌트에서 생성되지 않는다.
// 중앙화 된 특별한 곳에서 State들이 생성된다.
// 좀 더 쉽게 얘기해서 중앙 state 관리소라고 생각하면 된다.

// 중앙 State 관리소에서 State를 생성하고, 만약 어떤 컴포넌트에서 State가 필요하다면 컴포넌트가 어디에 위치하고 있든 상관없이 State를 불러와서 사용할 수 있다.
// 이렇게 특정 컴포넌트에 종속되어 있는 것이 아니라 중앙 state 관리소에서 생성된 State를 Global state라고 한다.
// 즉, 이러한 값들을 관리하는 것을 전역 상태 관리 라고 한다.

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// Context API
// React 자체적으로 제공하는 전역 상태 관리 도구이기 때문에 Global State를 관리하는 한 가지 옵션이 될 수 있다.
// 하지만 Context API는 복잡하지 않은 상태 관리 요구사항에 적합하다.
// 대규모 어플리케이션에서 Context API만으로는 다음과 같은 제한이 있어 Redux를 사용하는 것이 더 효과적이다

// 1. 성능 최적화
// Context API는 Provider 하위의 모든 컴포넌트를 리렌더링하게 할 수 있다.
// 상태가 변경될 때마다 관련된 모든 컴포넌트가 불필요하게 업데이트 되는 것을 막기 위해 복잡한 최적화가 필요하다.
// 반면, Redux는 상태 변경 시 관련된 컴포넌트만 선택적으로 업데이트를 할 수 있어 성능 관리가 용이하다.

// 2. 상태 로직의 중앙화와 일관성
// Redux는 애플리케이션의 상태를 하나의 저장소(store)에 저장한다.
// 이로 인해 상태 로직이 중앙에서 관리되어 더 일관성 있고, 예측 가능한 상태 변경이 가능해진다.
// 또한, 모든 상태 변경 로직이 리듀서(reducers)에 의해 처리되기 때문에 디버깅과 테스팅이 용이하다.

// 3. 강력한 미들웨어와 개발 도구
// Redux는 다양한 미들웨어를 지원하여 비동기 작업, 로깅, 상태 변경에 대한 추가 처리 등 복잡한 기능을 구현할 수 있다.
// 또한 Redux DevTools와 같은 강력한 개발 도구를 통해 상태 변화를 시각적으로 모니터링하고, 이전 상태로 롤백하는 등의 기능을 제공한다.

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// 도식화

// 1. View에서 액션이 일어난다.
// 2. dispatch에서 action이 일어나게 된다.
// 3. action에 의한 reducer함수가 실행되기 전에 middleware가 작동한다.
// 4. middleware에서 명령내린 일을 수행하고 난 뒤, reducer 함수를 실행한다. (3, 4번은 아직 몰라도 된다.)
// 5. reducer의 실행 결과 store에 새로운 값을 저장한다.
// 6. store의 state에 subscribe하고 있던 UI에 변경된 값을 준다.

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// 1. 리듀서에게 보낼 명령 만들기

// 1-1) 리듀서에게 number에 +1을 하라고 명령(Action)을 보내야 한다.
// 1-2) 명령(Action)을 보내기 전에 명령(Action)을 만들어야 한다.
// 1-3) 행동을 코드로 나타내면 객체로 만든다. 그래서 이것을 액션 객체라고 한다.

// 액션 객체는 반드시 type이라는 key를 가져야 한다.
// 그 이유는 우리가 이 액션 객체를 리듀서에게 보냈을 때, 리듀서는 객체 안에서 type이라는 key를 보기 때문이다

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// 2. 명령 (액션 객체) 보내기

// 명령(Action)을 만든 후, 리듀서에게 명령(Action)을 보내야 한다.
// 조금 더 정확하게 표현하게 위해서 지금부터는 명령(Action)이 아닌 액션 객체라고 표현해야 한다.

// 액션 객체를 리듀서로 보내기 위해서는 새로운 훅을 사용해야 한다.
// 그 훅은 useDispatch라는 훅이다.
// react-redux에서 import한 후에 사용할 수 있으며, 우리가 만든 액션 객체를 리듀서로 보내주는 역할을 하는 훅이다.

// useDispatch 훅을 사용하기 위해서는 컴포넌트 안에서 dispatch라는 변수를 생성해야 한다.
// const dispatch = useDispatch();

// 여기서 중요한 부분은 생성한 dispatch는 함수라는 것이다.
// 그래서 우리는 dispatch를 사용할 때 ()를 붙여서 함수를 실행한다.

// dispatch를 사용할 때 ()안에 액션 객체를 넣어준다.

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// 3. 리듀서가 액션 객체를 받아 상태를 바꾸는 원리

// 3-1) 컴포넌트로부터 dispatch를 통해 액션 객체를 전달받는다.
// 3-2) action 안에 있는 type을 switch문을 통해 하나씩 검사해서, 일치하는 case를 찾는다.
// 3-3) type과 case가 일치하는 경우에, 해당 코드가 실행되고 새로운 state를 반환(return) 한다.
// 3-4) 리듀서가 새로운 state를 반환하면, 그게 새로운 모듈의 state가 된다.

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// 정리

// action 객체 : 반드시 type이란 key를 가져야 하는 객체로, 리듀서로 보낼 명령이다.
// dispatch : action 객체를 reducer로 보내는 전달자 함수이다.
// reducer : dispatch를 통해 전달받은 action 객체를 검사하고, 조건이 일치했을 때 새로운 상태값을 만들어내는 or 변화를 만들어내는 함수이다.

// dispatch를 사용하기 위해서 useDispatch()라는 훅을 이용해야 한다.
// dispatch는 스토어의 내장 함수 중 하나이다.
// dispatch는 action을 발생시키는 정도로 이해하면 된다.
// dispatch라는 함수에는 action을 파라미터로 전달한다. ex : dispatch(action)
// action 객체 type의 value는 대문자로 작성한다. (JS에서 상수는 대문자로 작성하는 룰이 있다)

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// Action creator 사용 이유

// 1. 휴먼 에러 (오타) 방지
// action 객체의 type: value를 상수로 만들어놓았기 때문에, 개발 툴에서 자동 완성 등의 보조 기능을 지원받을 수 있다.
// 그래서 의도치 않은 휴먼 에러 (오타)를 없앨 수 있다.

// 2. 유지보수의 효율성 증가
// Action Creator가 만약 100군데에서 쓰이고 있는 상태일 때, 만약 그것을 바꿔야 하는 상황이 온다면
// 단 한 번의 수정으로 100군데의 모든 수정 사항을 반영할 수 있다.

// 3. 코드 가독성
// 모듈 파일에서 Action Creator가 일목요연하게 정리가 되어있으면, 내가 아닌 다른 개발자가 보았을 때 해당 모듈이 가지고 있는 모든 Action들을 한 눈에 알 수 있다.
// 즉, 그 자체가 Action들의 리스트 업을 해주는 역할을 갖게 되는 것이다.

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// Payload

// 지금까지 ~을이라는 목적어가 없었다면, 이제는 그 목적어가 생긴 것이고 목적어도 Action 객체에 담아서 같이 보내줘야 한다.
// 이렇게 Action 객체에 같이 담아 보내주는 것을 payload라고 한다.
// 예를 들어, 만약 10을 더하라는 것을 리듀서에게 보내고 싶으면 Action 객체에 payload를 같이 담아주는 것이다.

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// payload를 이용하여 기능 구현하기

// 1. 사용자가 입력한 값을 받을 input 구현하기
// 2. Action Creator 작성하기
// 3. 리듀서 작성하기
// 4. 구현된 기능 테스트 하기

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// Ducks 패턴

// Redux 앱을 구성할 때 사용하는 방법론 중 하나이다.
// 일반적으로 분산되어 있던 Action 타입, Action 생성자, reducer를 하나의 파일로 구성하는 방식을 말한다.
// Redux 관련 코드의 관리를 보다 간결하고 모듈화하여 관리할 수 있도록 돕는다.

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

// 1. Reducer 함수를 export default 한다.
// 2. Action creator 함수들을 export 한다.
// 3. Action type은 app / reducer / ACTION_TYPE 형태로 작성한다.

// (외부 라이브러리로서 사용될 경우 또는 외부 라이브러리가 필요로 할 경우에는 UPPER_SNAKE_CASE 로만 작성해도 된다.)

// 따라서 모듈 파일 1개에 "Action Type", "Action Creator", "Reducer" 가 모두 존재하는 작성 방식이다.

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

import React, { useState } from "react";
import { useSelector } from "react-redux";
import { useDispatch } from "react-redux";
import { addNumber, removeNumber } from "./redux/modules/counter";
// import { minusOne, plusOne } from "./redux/modules/counter";

const App = () => {
    const [count, setCount] = useState(0);
    const dispatch = useDispatch();
    const counterStore = useSelector((state) => state.counter);

    // console.log("state", counterStore);

    return (
        <div>
            {counterStore.number}
            <br />
            {/* <button
                onClick={() => {
                    dispatch(plusOne()); // Action 객체를 Action creator로 변경한다.
                }}
            >
                +1
            </button>
            <button
                onClick={() => {
                    dispatch(minusOne()); // Action 객체를 Action creator로 변경한다.
                }}
            >
                -1
            </button> */}
            <input
                type="number"
                value={count}
                onChange={(e) => {
                    // e.target.value는 문자열이다.
                    // 문자형을 숫자형으로 형 변환해주기 위해서 +를 붙힌다.
                    setCount(+e.target.value);
                }}
            />
            <br />
            <button
                onClick={() => {
                    dispatch(addNumber(count)); // Action 객체를 Action creator로 변경한다.
                }}
            >
                더하기
            </button>
            <button
                onClick={() => {
                    dispatch(removeNumber(count)); // Action 객체를 Action creator로 변경한다.
                }}
            >
                빼기
            </button>
        </div>
    );
};

export default App;
